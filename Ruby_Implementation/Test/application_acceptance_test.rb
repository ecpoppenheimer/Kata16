# frozen_string_literal: true

require "tty-prompt"
require "tty/prompt/test"
require 'rspec/autorun'
require '../payment'
require '../database'
require '../application'
require '../processor'

# Unfortunately I seem to have to include this or prints after the prompt get printed awkwardly in the middle of the tests
def silence_stream(stream=STDOUT)
  original_stream = stream.dup
  stream.reopen(File.open('/dev/null', 'w'))
  yield
ensure
  stream.reopen(original_stream)
end

def redirect_stream(stream=STDOUT, path)
  original_stream = stream.dup
  stream.reopen(File.open(path, 'w'))
  yield
ensure
  stream.reopen(original_stream)
end

describe "obtain_database" do
  # Setup.  Configure prompt as a test object, rather than a normal prompt
  let(:prompt) {TTY::Prompt::Test.new}

  it "It can create a new database, create and process a payment to the database, and save the database." do
    # Unfortunately I seem to have issues with the test prompt and multiple invocations of the program, so I will have
    # to spread out calls into their own example.  But since I explicitly need to test call-to-call here, I cannot have
    # the temp database deleted.  Which means I have to do cleanup explicitly for these tests.
    begin
      File.delete("temp_test_db.dat")
    rescue Errno::ENOENT
    end

    silence_stream do
      # Create a new database, create a new payment, process it, then quit
      prompt.input.puts "1"
      prompt.input.puts "1"
      prompt.input.puts ""
      prompt.input.puts "12.75"
      prompt.input.puts "1"
      prompt.input.puts "5"
      prompt.input.rewind
      expect{main("temp_test_db.dat", prompt)}.to_not raise_error
    end
  end

  it "can load a previously created database, and view the payment that was added." do
    # Open the application again and view the payment to ensure it was correctly handled and survived the closure and re-load
    prompt.input.puts "3"
    prompt.input.puts "1"
    prompt.input.puts "5"
    prompt.input.rewind

    # I can't read outputs generated by the damn prompts.  But using a similar trick to what I did to silence the stream
    # I can capture the outputs to a text file, and then check that text file
    redirect_stream('temp.txt') do
      expect{main("temp_test_db.dat", prompt)}.to_not raise_error
    end
    output_content = File.read('temp.txt')
    expect(output_content).to include('Value: 12.75')

    # Cleanup
    begin
      File.delete("temp_test_db.dat")
    rescue Errno::ENOENT
    end
    begin
      File.delete("temp.txt")
    rescue Errno::ENOENT
    end
  end

  it "can repair and successfully process a broken payment" do
    begin
      File.delete("temp_test_db.dat")
    rescue Errno::ENOENT
    end

    # For this test, I'm not sure I can select the FailingPayment option from the menu, so I will manually create
    # a database with a failed payment, then try to fix it with the prompts.
    db = Database.new()
    payment = FailingPayment.new(database: db, value: 15)
    processor = Processor.new(db)
    silence_stream do
      processor.process_payment(payment)
    end
    db.save("temp_test_db.dat")

    # Run the application, fix the payment, and process
    redirect_stream('temp.txt') do
      prompt.input.puts "4"
      prompt.input.puts ""
      prompt.input.puts ""
      prompt.input.puts "69"
      prompt.input.puts "1"
      prompt.input.puts "5"
      prompt.input.rewind
      main("temp_test_db.dat", prompt)
    end
    output_content = File.read('temp.txt')
    expect(output_content).to include ("Beginning processing of payment of 69.00 with id #0.")
    expect(output_content).to include('Processing completed!')

    # Cleanup
    begin
      File.delete("temp_test_db.dat")
    rescue Errno::ENOENT
    end
    begin
      File.delete("temp.txt")
    rescue Errno::ENOENT
    end
  end
end